# TODO: マルチステージビルド
# - ステージ1
#     - Goが動く環境を設定、ホスト側のGoプロジェクトをまるっとコピー、必要なモジュールをダウンロードした状態に
#       →コンテナに入って、go testを実行できる状態に
#     - Goアプリケーションの実行ファイルをビルドして実行
#       →コンテナ外から、単純にGoアプリケーションとして使用できる状態に
# - ステージ2
#     - めちゃくちゃ軽いベースイメージ上にステージ1で作ったGoアプリケーションの実行ファイルだけをコピーして実行

## ステージ1: Goアプリケーションの実行ファイルをビルド
#FROM golang:1.21.1 as builder
#
## /appディレクトリを作成して移動
#WORKDIR /app
#
## プロジェクトのコピー
#COPY . .
#
## 必要なGoモジュールをダウンロード
#RUN go mod download
#
## Goアプリケーションの実行ファイルをビルド
#RUN go build -o sample_app ./cmd/sample_app/*.go
#
## ステージ2: Goアプリケーションの実行ファイルを実行
#FROM alpine:3.20.2
#
## ステージ1でビルドしたGoアプリケーションの実行ファイルをルートディレクトリへコピー
#COPY --from=builder /app/sample_app /
#
## アプリケーションの実行
#CMD ["/sample_app"]


# Goアプリケーションをビルドして実行
FROM golang:1.21.1

# /appディレクトリの作成&移動
WORKDIR /app

# プロジェクトのコピー
# <A. ホスト側のパス(基準:ビルドコンテキストで指定したディレクトリ)> <B. コンテナ側のパス(基準:WORKDIR)>
# で、ホスト側のA.配下のディレクトリ、ファイルをコンテナのB. ディレクトリ配下にコピーするという意味になる。
# docker build時にアクセス可能なホスト側のファイル・ディレクトリという形。このスコープから外れたディレクトリ・ファイルには触れない。
# 素のdockerの場合:
#   ビルドコンテキストは、docker build -f <Dockerfileのパス> <コンテキストのパス> で指定できる。
#   docker build のみだと、カレントディレクトリのDockerfile, コンテキストもカレントディレクトリとみなされる。
# docker-composeの場合:
#   docker-compose.ymlのcontextで指定する「docker-compose.ymlファイルが存在するディレクトリからの相対パス」で設定する(必須パラメータ)
#   docker-compose upではどのdocker-compose.ymlを使うかを -f で指定できる。が、コマンドからコンテキストは設定できない。
#   素のdocker buildコマンドとは違って、コマンド実行時のカレントディレクトリは関係なく、明示的な指定が求められる。
COPY . .

# 必要なGoモジュールをダウンロード
RUN go mod download

# Goアプリケーション実行ファイルのビルド
RUN go build -o /sample_app ./cmd/sample_app/*.go

# Goアプリケーションの実行
CMD ["./sample_app"]
